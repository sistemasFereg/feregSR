{"version":3,"file":"BackgroundFetch.js","sourceRoot":"","sources":["../src/BackgroundFetch.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,mBAAmB,EAAE,MAAM,kBAAkB,CAAC;AACjE,OAAO,KAAK,WAAW,MAAM,mBAAmB,CAAC;AAEjD,OAAO,EAEL,qBAAqB,EACrB,qBAAqB,GACtB,MAAM,yBAAyB,CAAC;AACjC,OAAO,mBAAmB,MAAM,uBAAuB,CAAC;AAExD,MAAM,CAAC,KAAK,UAAU,cAAc;IAClC,IAAI,QAAQ,CAAC,EAAE,KAAK,SAAS,EAAE;QAC7B,OAAO,qBAAqB,CAAC,SAAS,CAAC;KACxC;IACD,OAAO,mBAAmB,CAAC,cAAc,EAAE,CAAC;AAC9C,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,uBAAuB,CAAC,eAAuB;IACnE,IAAI,CAAC,mBAAmB,CAAC,uBAAuB,EAAE;QAChD,OAAO;KACR;IACD,WAAW;IACX,MAAM,mBAAmB,CAAC,uBAAuB,CAAC,eAAe,CAAC,CAAC;AACrE,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,iBAAiB,CACrC,QAAgB,EAChB,UAAkC,EAAE;IAEpC,IAAI,CAAC,mBAAmB,CAAC,iBAAiB,EAAE;QAC1C,MAAM,IAAI,mBAAmB,CAAC,iBAAiB,EAAE,mBAAmB,CAAC,CAAC;KACvE;IACD,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;QACxC,MAAM,IAAI,KAAK,CACb,SAAS,QAAQ,2FAA2F,CAC7G,CAAC;KACH;IACD,MAAM,mBAAmB,CAAC,iBAAiB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;AACjE,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,mBAAmB,CAAC,QAAgB;IACxD,IAAI,CAAC,mBAAmB,CAAC,mBAAmB,EAAE;QAC5C,MAAM,IAAI,mBAAmB,CAAC,iBAAiB,EAAE,qBAAqB,CAAC,CAAC;KACzE;IACD,MAAM,mBAAmB,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;AAC1D,CAAC;AAED,OAAO,EAAE,qBAAqB,IAAI,MAAM,EAAE,qBAAqB,IAAI,MAAM,EAAE,CAAC","sourcesContent":["import { Platform, UnavailabilityError } from '@unimodules/core';\nimport * as TaskManager from 'expo-task-manager';\n\nimport {\n  BackgroundFetchOptions,\n  BackgroundFetchResult,\n  BackgroundFetchStatus,\n} from './BackgroundFetch.types';\nimport ExpoBackgroundFetch from './ExpoBackgroundFetch';\n\nexport async function getStatusAsync(): Promise<BackgroundFetchStatus | null> {\n  if (Platform.OS === 'android') {\n    return BackgroundFetchStatus.Available;\n  }\n  return ExpoBackgroundFetch.getStatusAsync();\n}\n\nexport async function setMinimumIntervalAsync(minimumInterval: number): Promise<void> {\n  if (!ExpoBackgroundFetch.setMinimumIntervalAsync) {\n    return;\n  }\n  // iOS only\n  await ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n}\n\nexport async function registerTaskAsync(\n  taskName: string,\n  options: BackgroundFetchOptions = {}\n): Promise<void> {\n  if (!ExpoBackgroundFetch.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync');\n  }\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(\n      `Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`\n    );\n  }\n  await ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n}\n\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync');\n  }\n  await ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n}\n\nexport { BackgroundFetchResult as Result, BackgroundFetchStatus as Status };\n"]}